'use strict';

const {isMainThread} = require('node:worker_threads');

//
// this is the startup code. it's only run in the main thread.
//
// it sets up the writer, the patcher, and listeners for all the events that
// will be written to the log file.
//

module.exports = function initRouteMetrics({type}) {
  if (!isMainThread) {
    // for some reason, main is invoked in the worker thread after it's
    // invoked in the main thread. i guess we could treat this as a meta-
    // esm-type and enabled the patcher in the worker thread, but there
    // is not communications channel then, so we can't forward messages
    // to the main thread. this may not be the best solution, but the optimal
    // solution is for the user to --import the esm version. maybe this
    // should only be an esm module? would really simplify things.
    return;
  }

  // it's only one thing, but use an array so it's possible to add a user-
  // specific agent at runtime (at some point in the future).
  const AGENTS = ['@contrast/agent'];

  // node 16.19.1 made -r @contrast/agent not accessible via require patching
  // and it's not visible to patching or loader hooks when using --import, so
  // look at execArgv. it's a hack, but it's more straightforward than the way
  // it was done before.
  // https://github.com/nodejs/node/commit/b02d895137
  let agentsToBeEmitted = [];
  // let's find @contrast/agent if it's there.
  for (let i = 0; i < process.execArgv.length; i++) {
    if (['-r', '--require', '--import'].includes(process.execArgv[i])) {
      const ix = AGENTS.indexOf(process.execArgv[i + 1]);
      if (ix >= 0) {
        agentsToBeEmitted.push(AGENTS[ix]);
      }
    }
  }

  //
  // startup code. all code in this file is executed in the main thread.
  // thread-specific code is in other files, e.g., setup-patcher.js.
  //
  const makeHeader = require('./writer/make-header');

  //
  // get the configuration and create the log file writer
  //
  const {config, errors} = require('./config/agent-config').get();
  const Writer = require('./writer/make-writer');

  const options = {
    streamOptions: {
      // if logging all loads this generates many log entries very fast. maybe
      // allow it to be the highWaterMark multiplier if set? e.g., 1 means
      // 1048576, 2 means 2097152, etc. if not, default of 16K is usually fine.
      highWaterMark: config.LOG_ALL_LOADS ? 1048576 : undefined
    }
  };
  const writer = new Writer(config.LOG_FILE, options);

  //
  // write the header to the log file, then write any errors detected
  // in the configuration. nothing is written to the console if the
  // log file is writable.
  //
  const {header, errors: headerErrors} = makeHeader('1.0.0', config);
  writer.write({type: 'header'}, header);
  if (errors.unknown.length) {
    writer.write({type: 'unknown-config-items'}, errors.unknown.join(', '));
  }
  if (errors.invalid.length) {
    writer.write({type: 'invalid-config-values'}, errors.invalid.join(', '));
  }
  if (headerErrors.length) {
    writer.write({type: 'header-errors'}, headerErrors.join(', '));
  }

  //
  // routes are emitted by the patched http/https/http2 code. type 'route' used
  // to be known as 'metric' but that was too generic and confusing.
  //
  const routeListener = (m) => {  // main only
    writer.write({type: 'route'}, m);
  };
  const routeEmitter = require('./route-emitter');
  routeEmitter.on('route', routeListener);

  //
  // timeseries capture data that is sampled on a regular interval, unlike
  // patches, loads, and routes, which are generated by events.
  //

  // the always-enabled cpu and memory time series
  function tsCallback(cpuAndMem) {
    writer.write({type: 'proc'}, cpuAndMem);
  }
  const timeSeriesOptions = {tsCallback};

  // optional GC time series
  if (config.GARBAGE_COLLECTION) {
    timeSeriesOptions.gcCallback = function gcListener(gcStats) {
      writer.write({type: 'gc'}, gcStats);
    };
  }
  // optional event loop time series
  if (config.EVENTLOOP) {
    timeSeriesOptions.elCallback = function elListener(elPercentiles) {
      writer.write({type: 'eventloop'}, elPercentiles);
    };
  }

  // undocumented interval setting, primarily for testing.
  let interval = process.env.CSI_ROUTE_METRICS_TIME_SERIES_INTERVAL || 1000;
  interval = Number(interval);

  const TimeSeries = require('./time-series');
  const timeSeries = new TimeSeries(interval, timeSeriesOptions);
  // should the constructor unref() the interval?
  timeSeries.interval.unref();

  for (const agent of agentsToBeEmitted) {
    writer.write({type: 'patch'}, {name: agent});
  }

  //
  // setup the patcher for the main thread. it will also be set up in the
  // loader thread, but the loader thread event listeners just augment the
  // events then forward them to the main thread to be written to the log file.
  //
  // THIS IS DONE LAST SO WE DON'T SEE ALL OF OUR OWN LOADS.
  //
  const patchListener = (m) => {
    // if it's an error make it concise; there's only one place in each thread
    // where files are patched, so there's no need for a stack trace.
    // a stack trace.
    if (m instanceof Error) {
      const { code, message } = m;
      const patchError = {};
      if (code) {
        patchError.code = code;
      }
      patchError.message = message;
      writer.write({ type: 'patch-error' }, patchError);
      return;
    }
    // normal case - just write the log
    writer.write({ type: 'patch' }, m);
  };

  // listen for load events and write them to the log. a file being
  // loaded will emit either a load or a patch event, not both.
  const loadListener = (m) => {
    writer.write({ type: 'load' }, m);
  };

  const setupPatcher = require('./setup-patcher');
  setupPatcher(patchListener, loadListener);

  // this should always be true now; this mostly serves as delineation that the
  // following code is all about setting up and handling the loader thread.
  if (type === 'esm') {
    // function to receive messages from the loader thread. all it does is pass
    // them to the writer.
    async function portMessageHandler(message) {
      // log it? yes, but slightly more complex because we're receiving the
      // message from the loader thread which added a threadId and timestamp.
      const {type, ts, tid, m: entry} = message;
      await writer.write({type, ts, tid}, entry);
    }

    // ideally we'd wait on this, but once register has been called the hooks are
    // in place and nothing remains to be done.
    (async() => {
      const registerHooks = (await import('./esm-hooks/index.mjs')).default;
      await registerHooks({app_dir: header.app_dir}, portMessageHandler);
    })();
  }

};
