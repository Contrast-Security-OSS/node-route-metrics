/*
 * Copyright: 2024 Contrast Security, Inc
 * Contact: support@contrastsecurity.com
 * License: Commercial

 * NOTICE: This Software and the patented inventions embodied within may only be
 * used as part of Contrast Securityâ€™s commercial offerings. Even though it is
 * made available through public repositories, use of this Software is subject to
 * the applicable End User Licensing Agreement found at
 * https://www.contrastsecurity.com/enduser-terms-0317a or as otherwise agreed
 * between Contrast Security and the End User. The Software may not be reverse
 * engineered, modified, repackaged, sold, redistributed or otherwise used in a
 * way not consistent with the End User License Agreement.
 */

import fetch, * as all from 'node-fetch';

let patched = all;
if (!Object.isExtensible(all)) {
  const objectDesc = Object.getOwnPropertyDescriptors(all);

  for (const key in objectDesc) {
    if (key === 'isRedirect') {
      objectDesc[key].value = function() {
        return 'i-am-redirect';
      };
    }
  }
  const proto = Object.getPrototypeOf(all) || null;
  patched = Object.create(proto, objectDesc);
} else {
  // simpler patching, but i don't think this can happen.
  throw new Error('node-fetch module object is not sealed');
}

export default fetch;

export const {
  AbortError,
  Blob,
  FetchError,
  File,
  FormData,
  Headers,
  Request,
  Response,
  blobFrom,
  blobFromSync,
  fileFrom,
  fileFromSync,
  isRedirect,
} = patched;
